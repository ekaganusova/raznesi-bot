import asyncio
import logging
import os
import requests
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENROUTER_KEY = os.getenv("OPENROUTER_KEY")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Flask
app = Flask(__name__)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(format="%(asctime)s ‚Äî %(levelname)s ‚Äî %(message)s", level=logging.INFO)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram-–±–æ—Ç–∞
application = Application.builder().token(TELEGRAM_TOKEN).build()

@app.route("/")
def index():
    return "OK", 200

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        update = Update.de_json(request.get_json(force=True), application.bot)
        asyncio.run(application.process_update(update))
        return 'ok'
    except Exception as e:
        logging.error("–û—à–∏–±–∫–∞ webhook:\n%s", e)
        return 'error', 500
    update = Update.de_json(request.get_json(force=True), application.bot)
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    loop.create_task(application.process_update(update))
    return "ok"

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start —Å –∫–Ω–æ–ø–∫–æ–π
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton("üî•–ñ–ú–£ –ù–ê –ö–ù–û–ü–ö–£üî•", url="https://t.me/ekaterina_ganusova")]]
    markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç!\n"
        "–Ø –±–æ—Ç, —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Å –ø–æ–º–æ—â—å—é AI‚ú®, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä—è—Ç—å –±–∏–∑–Ω–µ—Å-–∏–¥–µ–∏ –Ω–∞ –ø—Ä–æ—á–Ω–æ—Å—Ç—å. "
        "–ù–∞–ø–∏—à–∏ —Å–≤–æ—é ‚Äî –∏ —è —É—Å—Ç—Ä–æ—é –µ–π —Ä–∞–∑–Ω–æ—Å –∫–∞–∫ –º–∞—Ä–∫–µ—Ç–æ–ª–æ–≥: –∂—ë—Å—Ç–∫–æ, —Å —é–º–æ—Ä–æ–º –∏ –ø–æ –¥–µ–ª—É.\n\n"
        "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:\n"
        "1. –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —Å–≤–æ—é –∏–¥–µ—é.\n"
        "2. –ü–æ–ª—É—á–∏ —Ä–∞–∑–Ω–æ—Å.\n"
        "3. –ï—Å–ª–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ —Ö–æ—á–µ—à—å —Ç–∞–∫–æ–≥–æ –∂–µ –±–æ—Ç–∞ ‚Äî –∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—Éüëáüèª",
        reply_markup=markup
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_message = update.message.text
        logging.info("–ü–û–õ–£–ß–ï–ù–û: %s", user_message)

        headers = {
            "Authorization": f"Bearer {OPENROUTER_KEY}",
            "Content-Type": "application/json",
        }

        data = {
            "model": "openai/gpt-3.5-turbo",
            "messages": [{"role": "user", "content": user_message}],
        }

        response = requests.post("https://openrouter.ai/api/v1/chat/completions", headers=headers, json=data, timeout=15)
        response.raise_for_status()
        answer = response.json()["choices"][0]["message"]["content"]
        await update.message.reply_text(answer)
    except Exception as e:
        logging.error("GPT –û–®–ò–ë–ö–ê:\n%s", e)
        await update.message.reply_text("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ üò¢")

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
application.add_handler(CommandHandler("start", start))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook
def setup_webhook():
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/setWebhook"
    response = requests.post(url, data={"url": f"{WEBHOOK_URL}/webhook"})
    if response.status_code == 200:
        logging.info("Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: %s/webhook", WEBHOOK_URL)
    else:
        logging.error("–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook: %s", response.text)

if __name__ == "__main__":
    setup_webhook()
    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    app.run(host="0.0.0.0", port=10000)
